```
# 5 смертельных ошибок Arduino, которые делают даже опытные

![](https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_692345bd7d5be7777da73683_6923f01927715c566b6baa43/scale_1200)
*(Спойлер: проблема не в плате. И не в вас. Просто вы ещё не знаете этих трюков.)* 
Я потратил **три дня** , пытаясь понять, почему мой датчик движения пропускает срабатывания.
Код — простой. Плата — новая. Питание — стабильное.
А он — **молчит в самый ответственный момент** .
Оказалось — я делал **ошибку №2**  из этого списка.
А многие до сих пор делают **все пять**  — и думают, что «Arduino — ненадёжная игрушка».
Давайте разберём по-честному — без прикрас.

### Ошибка №1: delay() в основном цикле — «универсальный замедлитель»

Что часто пишут:

```
void loop() {
  readSensor();
  Serial.println(value);
  delay(1000);    // ВОТ ЭТО — ЗАМЕДЛИТЕЛЬ
}
```

**Что происходит** :
Во время delay(1000) — процессор **ничего не делает** .
Он не проверяет кнопки, не слушает I2C, не реагирует на прерывания.
Вы думаете — «ждёт», а на деле — **зависает на целую секунду** .

✅ **Как исправить — используем millis()** 

```
unsigned long lastPrint = 0;
const long interval = 1000;

void loop() {
  if (millis() - lastPrint >= interval) {
    readSensor();
    Serial.println(value);
    lastPrint = millis();   // обновляем время
  }
  // А здесь — можно проверять кнопки, Wi-Fi и всё остальное!
}
```

**Результат** :
— Кнопка реагирует **мгновенно** , даже при печати раз в секунду
— Никаких «потерь» событий

> Проверка: если в Serial Monitor строки идут «ровно по секундам» — вы на delay().
> Если «скачут» на 1–2 мс — вы уже на millis().

### Ошибка №2: Serial.print() в цикле без буферизации

Частая ошибка:

```
sensorValue = analogRead(A0);
Serial.print("Sensor: ");
Serial.print(sensorValue);
Serial.print(" | Time: ");
Serial.println(millis());   // 4 вызова подряд!
```

**Проблема** :
Каждый Serial.print() — отдельная передача.
При скорости 9600 baud:
— 1 символ ≈ 1 мс
— Строка из 30 символов = **30+ мс блокировки** 
→ Процессор «стоит», пока шлётся текст.

✅ **Исправляем — собираем строку заранее** 

```
char buffer[64];
snprintf(buffer, 64, "Sensor: %d | Time: %lu",
        analogRead(A0), millis());
Serial.println(buffer);   // одна отправка — быстро и чисто
```

**Эффект** :
— Передача в 4–5 раз быстрее
— Нет пропусков прерываний
— Даже на 115200 baud — стабильнее

> Совет: выводите отладку раз в 100 мс — не в КАЖДОМ loop().

### Ошибка №3: Питание датчиков от 5V Arduino при USB

Вы подключили:
— BME280
— сервопривод
— светодиодную ленту

→ всё к контакту 5V на Arduino

И не понимаете, почему:
— датчик «прыгает»,
— серво дёргается,
— плата иногда перезагружается.

**Истина** :
USB даёт **не больше 500 мА** .
Arduino Uno сама жрёт ~50 мА.
Остаётся 450 мА — а одна серва в пике может взять 300–500 мА.

✅ **Решение** :
— Используйте **внешний блок питания**  (5 В, 2 А+)
— Подключайте его:
  ▸ к разъёму **VIN**  (если блок 7–12 В),
  ▸ или напрямую к **5V**  (если блок стабилизирован на 5 В!)
— И **обязательно соедините GND блока и Arduino** 

> Проверьте мультиметром: напряжение на 5V при нагрузке должно быть ≥ 4.8 В.
> Меньше — значит, просадка. Система нестабильна.

### Ошибка №4: Кнопки без подтяжки

Часто пишут:

```
pinMode(buttonPin, INPUT);
...
if (digitalRead(buttonPin) == HIGH) { ... }
```

**Что происходит** :
Вход «висит в воздухе» → ловит шум, помехи, дребезг.
Одно нажатие = 3–5 срабатываний.

✅ **Правильно — включаем внутренний подтяжкой резистор** :

```
pinMode(buttonPin, INPUT_PULLUP);   // ВСТРОЕННЫЙ резистор (20–50 кОм)
...
if (digitalRead(buttonPin) == LOW) { ... }  // кнопка замыкает на GND
```

- **Программная защита от дребезга** :

```
if (digitalRead(btn) == LOW && millis() - lastPress > 50) {
  // ваше действие
  lastPress = millis();
}
```

### Ошибка №5: Нет Watchdog — «зависни и молчи»

Arduino может **зависнуть навсегда**  — и вы узнаете об этом только когда зайдёте в комнату.
Причины:
— бесконечный while
— ожидание ответа от «умершего» датчика
— зависший I2C

✅ **Включаем сторожевого пса — Watchdog Timer** 

```
#include <avr/wdt.h>

void setup() {
  wdt_enable(WDTO_2S);   // перезагрузка через 2 секунды, если не сбросить
}

void loop() {
  wdt_reset();   // «я жив!» — сбрасываем таймер
  // ваш код
}
```

**Результат** :
— При зависании — автоматическая перезагрузка
— Система — **самовосстанавливающаяся** 

> ⚠️ Важно: wdt_reset() должен быть в КАЖДОМ проходе loop().

###  Вывод: Arduino не тормозит. Вы просто *не слышите* , как он стонет.

Эти 5 ошибок — не «глупости». Их делают даже опытные.
Но теперь — вы знаете, как найти «невидимые» тормоза.
Проверьте свой код. Перепишите одну функцию. Перезапустите.
И посмотрите — как ваш проект внезапно **начнёт отвечать мгновенно** .
А если нашли свою «шестую» ошибку — напишите в комментариях.
Я добавлю её в обновлённую версию этой статьи — с упоминанием автора 

#ArduinoProTips
#EmbeddedSecrets
#FridayTechDrop

```